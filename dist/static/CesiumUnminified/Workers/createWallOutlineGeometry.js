define(["./defaultValue-81eec7ed","./Matrix2-c430e55a","./Transforms-4ee811db","./ComponentDatatype-9e86ac8f","./RuntimeError-8952249c","./GeometryAttribute-51ed9bde","./GeometryAttributes-32b29525","./IndexDatatype-bed3935d","./WallGeometryLibrary-7330e8e1","./_commonjsHelpers-3aae1032-26891ab7","./combine-3c023bda","./WebGLConstants-508b9636","./arrayRemoveDuplicates-1a15bd09","./PolylinePipeline-b3067570","./EllipsoidGeodesic-22d2f504","./EllipsoidRhumbLine-c86f0674","./IntersectionTests-4d132f79","./Plane-7e828ad8"],(function(e,i,t,n,o,r,s,a,l,d,m,u,p,f,c,h,g,y){"use strict";const E=new i.Cartesian3,_=new i.Cartesian3;function w(t){const r=(t=e.defaultValue(t,e.defaultValue.EMPTY_OBJECT)).positions,s=t.maximumHeights,a=t.minimumHeights;if(!e.defined(r))throw new o.DeveloperError("options.positions is required.");if(e.defined(s)&&s.length!==r.length)throw new o.DeveloperError("options.positions and options.maximumHeights must have the same length.");if(e.defined(a)&&a.length!==r.length)throw new o.DeveloperError("options.positions and options.minimumHeights must have the same length.");const l=e.defaultValue(t.granularity,n.CesiumMath.RADIANS_PER_DEGREE),d=e.defaultValue(t.ellipsoid,i.Ellipsoid.WGS84);this._positions=r,this._minimumHeights=a,this._maximumHeights=s,this._granularity=l,this._ellipsoid=i.Ellipsoid.clone(d),this._workerName="createWallOutlineGeometry";let m=1+r.length*i.Cartesian3.packedLength+2;e.defined(a)&&(m+=a.length),e.defined(s)&&(m+=s.length),this.packedLength=m+i.Ellipsoid.packedLength+1}w.pack=function(t,n,r){if(!e.defined(t))throw new o.DeveloperError("value is required");if(!e.defined(n))throw new o.DeveloperError("array is required");let s;r=e.defaultValue(r,0);const a=t._positions;let l=a.length;for(n[r++]=l,s=0;s<l;++s,r+=i.Cartesian3.packedLength)i.Cartesian3.pack(a[s],n,r);const d=t._minimumHeights;if(l=e.defined(d)?d.length:0,n[r++]=l,e.defined(d))for(s=0;s<l;++s)n[r++]=d[s];const m=t._maximumHeights;if(l=e.defined(m)?m.length:0,n[r++]=l,e.defined(m))for(s=0;s<l;++s)n[r++]=m[s];return i.Ellipsoid.pack(t._ellipsoid,n,r),n[r+=i.Ellipsoid.packedLength]=t._granularity,n};const H=i.Ellipsoid.clone(i.Ellipsoid.UNIT_SPHERE),b={positions:void 0,minimumHeights:void 0,maximumHeights:void 0,ellipsoid:H,granularity:void 0};return w.unpack=function(t,n,r){if(!e.defined(t))throw new o.DeveloperError("array is required");let s;n=e.defaultValue(n,0);let a=t[n++];const l=new Array(a);for(s=0;s<a;++s,n+=i.Cartesian3.packedLength)l[s]=i.Cartesian3.unpack(t,n);let d,m;if(a=t[n++],a>0)for(d=new Array(a),s=0;s<a;++s)d[s]=t[n++];if(a=t[n++],a>0)for(m=new Array(a),s=0;s<a;++s)m[s]=t[n++];const u=i.Ellipsoid.unpack(t,n,H),p=t[n+=i.Ellipsoid.packedLength];return e.defined(r)?(r._positions=l,r._minimumHeights=d,r._maximumHeights=m,r._ellipsoid=i.Ellipsoid.clone(u,r._ellipsoid),r._granularity=p,r):(b.positions=l,b.minimumHeights=d,b.maximumHeights=m,b.granularity=p,new w(b))},w.fromConstantHeights=function(i){const t=(i=e.defaultValue(i,e.defaultValue.EMPTY_OBJECT)).positions;if(!e.defined(t))throw new o.DeveloperError("options.positions is required.");let n,r;const s=i.minimumHeight,a=i.maximumHeight,l=e.defined(s),d=e.defined(a);if(l||d){const e=t.length;n=l?new Array(e):void 0,r=d?new Array(e):void 0;for(let i=0;i<e;++i)l&&(n[i]=s),d&&(r[i]=a)}return new w({positions:t,maximumHeights:r,minimumHeights:n,ellipsoid:i.ellipsoid})},w.createGeometry=function(o){const d=o._positions,m=o._minimumHeights,u=o._maximumHeights,p=o._granularity,f=o._ellipsoid,c=l.WallGeometryLibrary.computePositions(f,d,u,m,p,!1);if(!e.defined(c))return;const h=c.bottomPositions,g=c.topPositions;let y=g.length,w=2*y;const H=new Float64Array(w);let b,v=0;for(y/=3,b=0;b<y;++b){const e=3*b,t=i.Cartesian3.fromArray(g,e,E),n=i.Cartesian3.fromArray(h,e,_);H[v++]=n.x,H[v++]=n.y,H[v++]=n.z,H[v++]=t.x,H[v++]=t.y,H[v++]=t.z}const C=new s.GeometryAttributes({position:new r.GeometryAttribute({componentDatatype:n.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:H})}),A=w/3;w=2*A-4+A;const D=a.IndexDatatype.createTypedArray(A,w);let k=0;for(b=0;b<A-2;b+=2){const e=b,t=b+2,o=i.Cartesian3.fromArray(H,3*e,E),r=i.Cartesian3.fromArray(H,3*t,_);if(i.Cartesian3.equalsEpsilon(o,r,n.CesiumMath.EPSILON10))continue;const s=b+1,a=b+3;D[k++]=s,D[k++]=e,D[k++]=s,D[k++]=a,D[k++]=e,D[k++]=t}return D[k++]=A-2,D[k++]=A-1,new r.Geometry({attributes:C,indices:D,primitiveType:r.PrimitiveType.LINES,boundingSphere:new t.BoundingSphere.fromVertices(H)})},function(t,n){return e.defined(n)&&(t=w.unpack(t,n)),t._ellipsoid=i.Ellipsoid.clone(t._ellipsoid),w.createGeometry(t)}}));