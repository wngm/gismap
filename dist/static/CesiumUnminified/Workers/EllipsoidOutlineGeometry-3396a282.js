define(["exports","./GeometryOffsetAttribute-2bff0974","./Transforms-4ee811db","./Matrix2-c430e55a","./ComponentDatatype-9e86ac8f","./defaultValue-81eec7ed","./RuntimeError-8952249c","./GeometryAttribute-51ed9bde","./GeometryAttributes-32b29525","./IndexDatatype-bed3935d"],(function(e,t,i,r,o,n,a,s,u,m){"use strict";const f=new r.Cartesian3(1,1,1),l=Math.cos,d=Math.sin;function c(e){e=n.defaultValue(e,n.defaultValue.EMPTY_OBJECT);const i=n.defaultValue(e.radii,f),s=n.defaultValue(e.innerRadii,i),u=n.defaultValue(e.minimumClock,0),m=n.defaultValue(e.maximumClock,o.CesiumMath.TWO_PI),l=n.defaultValue(e.minimumCone,0),d=n.defaultValue(e.maximumCone,o.CesiumMath.PI),c=Math.round(n.defaultValue(e.stackPartitions,10)),p=Math.round(n.defaultValue(e.slicePartitions,8)),C=Math.round(n.defaultValue(e.subdivisions,128));if(c<1)throw new a.DeveloperError("options.stackPartitions cannot be less than 1");if(p<0)throw new a.DeveloperError("options.slicePartitions cannot be less than 0");if(C<0)throw new a.DeveloperError("options.subdivisions must be greater than or equal to zero.");if(n.defined(e.offsetAttribute)&&e.offsetAttribute===t.GeometryOffsetAttribute.TOP)throw new a.DeveloperError("GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.");this._radii=r.Cartesian3.clone(i),this._innerRadii=r.Cartesian3.clone(s),this._minimumClock=u,this._maximumClock=m,this._minimumCone=l,this._maximumCone=d,this._stackPartitions=c,this._slicePartitions=p,this._subdivisions=C,this._offsetAttribute=e.offsetAttribute,this._workerName="createEllipsoidOutlineGeometry"}c.packedLength=2*r.Cartesian3.packedLength+8,c.pack=function(e,t,i){if(!n.defined(e))throw new a.DeveloperError("value is required");if(!n.defined(t))throw new a.DeveloperError("array is required");return i=n.defaultValue(i,0),r.Cartesian3.pack(e._radii,t,i),i+=r.Cartesian3.packedLength,r.Cartesian3.pack(e._innerRadii,t,i),i+=r.Cartesian3.packedLength,t[i++]=e._minimumClock,t[i++]=e._maximumClock,t[i++]=e._minimumCone,t[i++]=e._maximumCone,t[i++]=e._stackPartitions,t[i++]=e._slicePartitions,t[i++]=e._subdivisions,t[i]=n.defaultValue(e._offsetAttribute,-1),t};const p=new r.Cartesian3,C=new r.Cartesian3,h={radii:p,innerRadii:C,minimumClock:void 0,maximumClock:void 0,minimumCone:void 0,maximumCone:void 0,stackPartitions:void 0,slicePartitions:void 0,subdivisions:void 0,offsetAttribute:void 0};c.unpack=function(e,t,i){if(!n.defined(e))throw new a.DeveloperError("array is required");t=n.defaultValue(t,0);const o=r.Cartesian3.unpack(e,t,p);t+=r.Cartesian3.packedLength;const s=r.Cartesian3.unpack(e,t,C);t+=r.Cartesian3.packedLength;const u=e[t++],m=e[t++],f=e[t++],l=e[t++],d=e[t++],_=e[t++],b=e[t++],y=e[t];return n.defined(i)?(i._radii=r.Cartesian3.clone(o,i._radii),i._innerRadii=r.Cartesian3.clone(s,i._innerRadii),i._minimumClock=u,i._maximumClock=m,i._minimumCone=f,i._maximumCone=l,i._stackPartitions=d,i._slicePartitions=_,i._subdivisions=b,i._offsetAttribute=-1===y?void 0:y,i):(h.minimumClock=u,h.maximumClock=m,h.minimumCone=f,h.maximumCone=l,h.stackPartitions=d,h.slicePartitions=_,h.subdivisions=b,h.offsetAttribute=-1===y?void 0:y,new c(h))},c.createGeometry=function(e){const a=e._radii;if(a.x<=0||a.y<=0||a.z<=0)return;const f=e._innerRadii;if(f.x<=0||f.y<=0||f.z<=0)return;const c=e._minimumClock,p=e._maximumClock,C=e._minimumCone,h=e._maximumCone,_=e._subdivisions,b=r.Ellipsoid.fromCartesian3(a);let y=e._slicePartitions+1,k=e._stackPartitions+1;y=Math.round(y*Math.abs(p-c)/o.CesiumMath.TWO_PI),k=Math.round(k*Math.abs(h-C)/o.CesiumMath.PI),y<2&&(y=2),k<2&&(k=2);let A=0,v=1;const w=f.x!==a.x||f.y!==a.y||f.z!==a.z;let P=!1,x=!1;w&&(v=2,C>0&&(P=!0,A+=y),h<Math.PI&&(x=!0,A+=y));const E=_*v*(k+y),D=new Float64Array(3*E),M=2*(E+A-(y+k)*v),g=m.IndexDatatype.createTypedArray(E,M);let V,G,O,T,z=0;const I=new Array(k),L=new Array(k);for(V=0;V<k;V++)T=C+V*(h-C)/(k-1),I[V]=d(T),L[V]=l(T);const R=new Array(_),N=new Array(_);for(V=0;V<_;V++)O=c+V*(p-c)/(_-1),R[V]=d(O),N[V]=l(O);for(V=0;V<k;V++)for(G=0;G<_;G++)D[z++]=a.x*I[V]*N[G],D[z++]=a.y*I[V]*R[G],D[z++]=a.z*L[V];if(w)for(V=0;V<k;V++)for(G=0;G<_;G++)D[z++]=f.x*I[V]*N[G],D[z++]=f.y*I[V]*R[G],D[z++]=f.z*L[V];for(I.length=_,L.length=_,V=0;V<_;V++)T=C+V*(h-C)/(_-1),I[V]=d(T),L[V]=l(T);for(R.length=y,N.length=y,V=0;V<y;V++)O=c+V*(p-c)/(y-1),R[V]=d(O),N[V]=l(O);for(V=0;V<_;V++)for(G=0;G<y;G++)D[z++]=a.x*I[V]*N[G],D[z++]=a.y*I[V]*R[G],D[z++]=a.z*L[V];if(w)for(V=0;V<_;V++)for(G=0;G<y;G++)D[z++]=f.x*I[V]*N[G],D[z++]=f.y*I[V]*R[G],D[z++]=f.z*L[V];for(z=0,V=0;V<k*v;V++){const e=V*_;for(G=0;G<_-1;G++)g[z++]=e+G,g[z++]=e+G+1}let q=k*_*v;for(V=0;V<y;V++)for(G=0;G<_-1;G++)g[z++]=q+V+G*y,g[z++]=q+V+(G+1)*y;if(w)for(q=k*_*v+y*_,V=0;V<y;V++)for(G=0;G<_-1;G++)g[z++]=q+V+G*y,g[z++]=q+V+(G+1)*y;if(w){let e=k*_*v,t=e+_*y;if(P)for(V=0;V<y;V++)g[z++]=e+V,g[z++]=t+V;if(x)for(e+=_*y-y,t+=_*y-y,V=0;V<y;V++)g[z++]=e+V,g[z++]=t+V}const B=new u.GeometryAttributes({position:new s.GeometryAttribute({componentDatatype:o.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:D})});if(n.defined(e._offsetAttribute)){const i=D.length,r=new Uint8Array(i/3),n=e._offsetAttribute===t.GeometryOffsetAttribute.NONE?0:1;t.arrayFill(r,n),B.applyOffset=new s.GeometryAttribute({componentDatatype:o.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:r})}return new s.Geometry({attributes:B,indices:g,primitiveType:s.PrimitiveType.LINES,boundingSphere:i.BoundingSphere.fromEllipsoid(b),offsetAttribute:e._offsetAttribute})},e.EllipsoidOutlineGeometry=c}));