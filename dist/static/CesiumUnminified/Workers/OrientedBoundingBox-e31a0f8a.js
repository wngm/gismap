define(["exports","./Transforms-4ee811db","./Matrix2-c430e55a","./RuntimeError-8952249c","./defaultValue-81eec7ed","./EllipsoidTangentPlane-0152c019","./ComponentDatatype-9e86ac8f","./Plane-7e828ad8"],(function(a,e,t,n,r,i,s,o){"use strict";function c(a,e){this.center=t.Cartesian3.clone(r.defaultValue(a,t.Cartesian3.ZERO)),this.halfAxes=t.Matrix3.clone(r.defaultValue(e,t.Matrix3.ZERO))}c.packedLength=t.Cartesian3.packedLength+t.Matrix3.packedLength,c.pack=function(a,e,i){return n.Check.typeOf.object("value",a),n.Check.defined("array",e),i=r.defaultValue(i,0),t.Cartesian3.pack(a.center,e,i),t.Matrix3.pack(a.halfAxes,e,i+t.Cartesian3.packedLength),e},c.unpack=function(a,e,i){return n.Check.defined("array",a),e=r.defaultValue(e,0),r.defined(i)||(i=new c),t.Cartesian3.unpack(a,e,i.center),t.Matrix3.unpack(a,e+t.Cartesian3.packedLength,i.halfAxes),i};const C=new t.Cartesian3,d=new t.Cartesian3,u=new t.Cartesian3,l=new t.Cartesian3,h=new t.Cartesian3,f=new t.Cartesian3,m=new t.Matrix3,x={unitary:new t.Matrix3,diagonal:new t.Matrix3};c.fromPoints=function(a,e){if(r.defined(e)||(e=new c),!r.defined(a)||0===a.length)return e.halfAxes=t.Matrix3.ZERO,e.center=t.Cartesian3.ZERO,e;let n;const i=a.length,s=t.Cartesian3.clone(a[0],C);for(n=1;n<i;n++)t.Cartesian3.add(s,a[n],s);const o=1/i;t.Cartesian3.multiplyByScalar(s,o,s);let p,M=0,w=0,g=0,b=0,y=0,O=0;for(n=0;n<i;n++)p=t.Cartesian3.subtract(a[n],s,d),M+=p.x*p.x,w+=p.x*p.y,g+=p.x*p.z,b+=p.y*p.y,y+=p.y*p.z,O+=p.z*p.z;M*=o,w*=o,g*=o,b*=o,y*=o,O*=o;const E=m;E[0]=M,E[1]=w,E[2]=g,E[3]=w,E[4]=b,E[5]=y,E[6]=g,E[7]=y,E[8]=O;const N=t.Matrix3.computeEigenDecomposition(E,x),T=t.Matrix3.clone(N.unitary,e.halfAxes);let P=t.Matrix3.getColumn(T,0,l),A=t.Matrix3.getColumn(T,1,h),I=t.Matrix3.getColumn(T,2,f),R=-Number.MAX_VALUE,S=-Number.MAX_VALUE,U=-Number.MAX_VALUE,D=Number.MAX_VALUE,L=Number.MAX_VALUE,q=Number.MAX_VALUE;for(n=0;n<i;n++)p=a[n],R=Math.max(t.Cartesian3.dot(P,p),R),S=Math.max(t.Cartesian3.dot(A,p),S),U=Math.max(t.Cartesian3.dot(I,p),U),D=Math.min(t.Cartesian3.dot(P,p),D),L=Math.min(t.Cartesian3.dot(A,p),L),q=Math.min(t.Cartesian3.dot(I,p),q);P=t.Cartesian3.multiplyByScalar(P,.5*(D+R),P),A=t.Cartesian3.multiplyByScalar(A,.5*(L+S),A),I=t.Cartesian3.multiplyByScalar(I,.5*(q+U),I);const v=t.Cartesian3.add(P,A,e.center);t.Cartesian3.add(v,I,v);const z=u;return z.x=R-D,z.y=S-L,z.z=U-q,t.Cartesian3.multiplyByScalar(z,.5,z),t.Matrix3.multiplyByScale(e.halfAxes,z,e.halfAxes),e};const p=new t.Cartesian3,M=new t.Cartesian3;function w(a,e,i,s,o,C,d,u,l,h,f){if(!(r.defined(o)&&r.defined(C)&&r.defined(d)&&r.defined(u)&&r.defined(l)&&r.defined(h)))throw new n.DeveloperError("all extents (minimum/maximum X/Y/Z) are required.");r.defined(f)||(f=new c);const m=f.halfAxes;t.Matrix3.setColumn(m,0,e,m),t.Matrix3.setColumn(m,1,i,m),t.Matrix3.setColumn(m,2,s,m);let x=p;x.x=(o+C)/2,x.y=(d+u)/2,x.z=(l+h)/2;const w=M;w.x=(C-o)/2,w.y=(u-d)/2,w.z=(h-l)/2;const g=f.center;return x=t.Matrix3.multiplyByVector(m,x,x),t.Cartesian3.add(a,x,g),t.Matrix3.multiplyByScale(m,w,m),f}const g=new t.Cartographic,b=new t.Cartesian3,y=new t.Cartographic,O=new t.Cartographic,E=new t.Cartographic,N=new t.Cartographic,T=new t.Cartographic,P=new t.Cartesian3,A=new t.Cartesian3,I=new t.Cartesian3,R=new t.Cartesian3,S=new t.Cartesian3,U=new t.Cartesian2,D=new t.Cartesian2,L=new t.Cartesian2,q=new t.Cartesian2,v=new t.Cartesian2,z=new t.Cartesian3,B=new t.Cartesian3,V=new t.Cartesian3,_=new t.Cartesian3,k=new t.Cartesian2,W=new t.Cartesian3,X=new t.Cartesian3,j=new t.Cartesian3,Z=new o.Plane(t.Cartesian3.UNIT_X,0);c.fromRectangle=function(a,e,c,C,d){if(!r.defined(a))throw new n.DeveloperError("rectangle is required");if(a.width<0||a.width>s.CesiumMath.TWO_PI)throw new n.DeveloperError("Rectangle width must be between 0 and 2*pi");if(a.height<0||a.height>s.CesiumMath.PI)throw new n.DeveloperError("Rectangle height must be between 0 and pi");if(r.defined(C)&&!s.CesiumMath.equalsEpsilon(C.radii.x,C.radii.y,s.CesiumMath.EPSILON15))throw new n.DeveloperError("Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)");let u,l,h,f,m,x,p;if(e=r.defaultValue(e,0),c=r.defaultValue(c,0),C=r.defaultValue(C,t.Ellipsoid.WGS84),a.width<=s.CesiumMath.PI){const n=t.Rectangle.center(a,g),r=C.cartographicToCartesian(n,b),s=new i.EllipsoidTangentPlane(r,C);p=s.plane;const M=n.longitude,z=a.south<0&&a.north>0?0:n.latitude,B=t.Cartographic.fromRadians(M,a.north,c,y),V=t.Cartographic.fromRadians(a.west,a.north,c,O),_=t.Cartographic.fromRadians(a.west,z,c,E),k=t.Cartographic.fromRadians(a.west,a.south,c,N),W=t.Cartographic.fromRadians(M,a.south,c,T),X=C.cartographicToCartesian(B,P);let j=C.cartographicToCartesian(V,A);const Z=C.cartographicToCartesian(_,I);let Y=C.cartographicToCartesian(k,R);const G=C.cartographicToCartesian(W,S),F=s.projectPointToNearestOnPlane(X,U),H=s.projectPointToNearestOnPlane(j,D),J=s.projectPointToNearestOnPlane(Z,L),K=s.projectPointToNearestOnPlane(Y,q),Q=s.projectPointToNearestOnPlane(G,v);return u=Math.min(H.x,J.x,K.x),l=-u,f=Math.max(H.y,F.y),h=Math.min(K.y,Q.y),V.height=k.height=e,j=C.cartographicToCartesian(V,A),Y=C.cartographicToCartesian(k,R),m=Math.min(o.Plane.getPointDistance(p,j),o.Plane.getPointDistance(p,Y)),x=c,w(s.origin,s.xAxis,s.yAxis,s.zAxis,u,l,h,f,m,x,d)}const M=a.south>0,Y=a.north<0,G=M?a.south:Y?a.north:0,F=t.Rectangle.center(a,g).longitude,H=t.Cartesian3.fromRadians(F,G,c,C,z);H.z=0;const J=Math.abs(H.x)<s.CesiumMath.EPSILON10&&Math.abs(H.y)<s.CesiumMath.EPSILON10?t.Cartesian3.UNIT_X:t.Cartesian3.normalize(H,B),K=t.Cartesian3.UNIT_Z,Q=t.Cartesian3.cross(J,K,V);p=o.Plane.fromPointNormal(H,J,Z);const $=t.Cartesian3.fromRadians(F+s.CesiumMath.PI_OVER_TWO,G,c,C,_);l=t.Cartesian3.dot(o.Plane.projectPointOntoPlane(p,$,k),Q),u=-l,f=t.Cartesian3.fromRadians(0,a.north,Y?e:c,C,W).z,h=t.Cartesian3.fromRadians(0,a.south,M?e:c,C,X).z;const aa=t.Cartesian3.fromRadians(a.east,G,c,C,j);return m=o.Plane.getPointDistance(p,aa),x=0,w(H,Q,K,J,u,l,h,f,m,x,d)},c.fromTransformation=function(a,e){return n.Check.typeOf.object("transformation",a),r.defined(e)||(e=new c),e.center=t.Matrix4.getTranslation(a,e.center),e.halfAxes=t.Matrix4.getMatrix3(a,e.halfAxes),e.halfAxes=t.Matrix3.multiplyByScalar(e.halfAxes,.5,e.halfAxes),e},c.clone=function(a,e){if(r.defined(a))return r.defined(e)?(t.Cartesian3.clone(a.center,e.center),t.Matrix3.clone(a.halfAxes,e.halfAxes),e):new c(a.center,a.halfAxes)},c.intersectPlane=function(a,i){if(!r.defined(a))throw new n.DeveloperError("box is required.");if(!r.defined(i))throw new n.DeveloperError("plane is required.");const s=a.center,o=i.normal,c=a.halfAxes,C=o.x,d=o.y,u=o.z,l=Math.abs(C*c[t.Matrix3.COLUMN0ROW0]+d*c[t.Matrix3.COLUMN0ROW1]+u*c[t.Matrix3.COLUMN0ROW2])+Math.abs(C*c[t.Matrix3.COLUMN1ROW0]+d*c[t.Matrix3.COLUMN1ROW1]+u*c[t.Matrix3.COLUMN1ROW2])+Math.abs(C*c[t.Matrix3.COLUMN2ROW0]+d*c[t.Matrix3.COLUMN2ROW1]+u*c[t.Matrix3.COLUMN2ROW2]),h=t.Cartesian3.dot(o,s)+i.distance;return h<=-l?e.Intersect.OUTSIDE:h>=l?e.Intersect.INSIDE:e.Intersect.INTERSECTING};const Y=new t.Cartesian3,G=new t.Cartesian3,F=new t.Cartesian3,H=new t.Cartesian3,J=new t.Cartesian3,K=new t.Cartesian3;c.distanceSquaredTo=function(a,e){if(!r.defined(a))throw new n.DeveloperError("box is required.");if(!r.defined(e))throw new n.DeveloperError("cartesian is required.");const i=t.Cartesian3.subtract(e,a.center,p),o=a.halfAxes;let c=t.Matrix3.getColumn(o,0,Y),C=t.Matrix3.getColumn(o,1,G),d=t.Matrix3.getColumn(o,2,F);const u=t.Cartesian3.magnitude(c),l=t.Cartesian3.magnitude(C),h=t.Cartesian3.magnitude(d);let f=!0,m=!0,x=!0;u>0?t.Cartesian3.divideByScalar(c,u,c):f=!1,l>0?t.Cartesian3.divideByScalar(C,l,C):m=!1,h>0?t.Cartesian3.divideByScalar(d,h,d):x=!1;const M=!f+!m+!x;let w,g,b;if(1===M){let a=c;w=C,g=d,m?x||(a=d,g=c):(a=C,w=c),b=t.Cartesian3.cross(w,g,J),a===c?c=b:a===C?C=b:a===d&&(d=b)}else if(2===M){w=c,m?w=C:x&&(w=d);let a=t.Cartesian3.UNIT_Y;a.equalsEpsilon(w,s.CesiumMath.EPSILON3)&&(a=t.Cartesian3.UNIT_X),g=t.Cartesian3.cross(w,a,H),t.Cartesian3.normalize(g,g),b=t.Cartesian3.cross(w,g,J),t.Cartesian3.normalize(b,b),w===c?(C=g,d=b):w===C?(d=g,c=b):w===d&&(c=g,C=b)}else 3===M&&(c=t.Cartesian3.UNIT_X,C=t.Cartesian3.UNIT_Y,d=t.Cartesian3.UNIT_Z);const y=K;y.x=t.Cartesian3.dot(i,c),y.y=t.Cartesian3.dot(i,C),y.z=t.Cartesian3.dot(i,d);let O,E=0;return y.x<-u?(O=y.x+u,E+=O*O):y.x>u&&(O=y.x-u,E+=O*O),y.y<-l?(O=y.y+l,E+=O*O):y.y>l&&(O=y.y-l,E+=O*O),y.z<-h?(O=y.z+h,E+=O*O):y.z>h&&(O=y.z-h,E+=O*O),E};const Q=new t.Cartesian3,$=new t.Cartesian3;c.computePlaneDistances=function(a,i,s,o){if(!r.defined(a))throw new n.DeveloperError("box is required.");if(!r.defined(i))throw new n.DeveloperError("position is required.");if(!r.defined(s))throw new n.DeveloperError("direction is required.");r.defined(o)||(o=new e.Interval);let c=Number.POSITIVE_INFINITY,C=Number.NEGATIVE_INFINITY;const d=a.center,u=a.halfAxes,l=t.Matrix3.getColumn(u,0,Y),h=t.Matrix3.getColumn(u,1,G),f=t.Matrix3.getColumn(u,2,F),m=t.Cartesian3.add(l,h,Q);t.Cartesian3.add(m,f,m),t.Cartesian3.add(m,d,m);const x=t.Cartesian3.subtract(m,i,$);let p=t.Cartesian3.dot(s,x);return c=Math.min(p,c),C=Math.max(p,C),t.Cartesian3.add(d,l,m),t.Cartesian3.add(m,h,m),t.Cartesian3.subtract(m,f,m),t.Cartesian3.subtract(m,i,x),p=t.Cartesian3.dot(s,x),c=Math.min(p,c),C=Math.max(p,C),t.Cartesian3.add(d,l,m),t.Cartesian3.subtract(m,h,m),t.Cartesian3.add(m,f,m),t.Cartesian3.subtract(m,i,x),p=t.Cartesian3.dot(s,x),c=Math.min(p,c),C=Math.max(p,C),t.Cartesian3.add(d,l,m),t.Cartesian3.subtract(m,h,m),t.Cartesian3.subtract(m,f,m),t.Cartesian3.subtract(m,i,x),p=t.Cartesian3.dot(s,x),c=Math.min(p,c),C=Math.max(p,C),t.Cartesian3.subtract(d,l,m),t.Cartesian3.add(m,h,m),t.Cartesian3.add(m,f,m),t.Cartesian3.subtract(m,i,x),p=t.Cartesian3.dot(s,x),c=Math.min(p,c),C=Math.max(p,C),t.Cartesian3.subtract(d,l,m),t.Cartesian3.add(m,h,m),t.Cartesian3.subtract(m,f,m),t.Cartesian3.subtract(m,i,x),p=t.Cartesian3.dot(s,x),c=Math.min(p,c),C=Math.max(p,C),t.Cartesian3.subtract(d,l,m),t.Cartesian3.subtract(m,h,m),t.Cartesian3.add(m,f,m),t.Cartesian3.subtract(m,i,x),p=t.Cartesian3.dot(s,x),c=Math.min(p,c),C=Math.max(p,C),t.Cartesian3.subtract(d,l,m),t.Cartesian3.subtract(m,h,m),t.Cartesian3.subtract(m,f,m),t.Cartesian3.subtract(m,i,x),p=t.Cartesian3.dot(s,x),c=Math.min(p,c),C=Math.max(p,C),o.start=c,o.stop=C,o};const aa=new t.Cartesian3,ea=new t.Cartesian3,ta=new t.Cartesian3;c.computeCorners=function(a,e){n.Check.typeOf.object("box",a),r.defined(e)||(e=[new t.Cartesian3,new t.Cartesian3,new t.Cartesian3,new t.Cartesian3,new t.Cartesian3,new t.Cartesian3,new t.Cartesian3,new t.Cartesian3]);const i=a.center,s=a.halfAxes,o=t.Matrix3.getColumn(s,0,aa),c=t.Matrix3.getColumn(s,1,ea),C=t.Matrix3.getColumn(s,2,ta);return t.Cartesian3.clone(i,e[0]),t.Cartesian3.subtract(e[0],o,e[0]),t.Cartesian3.subtract(e[0],c,e[0]),t.Cartesian3.subtract(e[0],C,e[0]),t.Cartesian3.clone(i,e[1]),t.Cartesian3.subtract(e[1],o,e[1]),t.Cartesian3.subtract(e[1],c,e[1]),t.Cartesian3.add(e[1],C,e[1]),t.Cartesian3.clone(i,e[2]),t.Cartesian3.subtract(e[2],o,e[2]),t.Cartesian3.add(e[2],c,e[2]),t.Cartesian3.subtract(e[2],C,e[2]),t.Cartesian3.clone(i,e[3]),t.Cartesian3.subtract(e[3],o,e[3]),t.Cartesian3.add(e[3],c,e[3]),t.Cartesian3.add(e[3],C,e[3]),t.Cartesian3.clone(i,e[4]),t.Cartesian3.add(e[4],o,e[4]),t.Cartesian3.subtract(e[4],c,e[4]),t.Cartesian3.subtract(e[4],C,e[4]),t.Cartesian3.clone(i,e[5]),t.Cartesian3.add(e[5],o,e[5]),t.Cartesian3.subtract(e[5],c,e[5]),t.Cartesian3.add(e[5],C,e[5]),t.Cartesian3.clone(i,e[6]),t.Cartesian3.add(e[6],o,e[6]),t.Cartesian3.add(e[6],c,e[6]),t.Cartesian3.subtract(e[6],C,e[6]),t.Cartesian3.clone(i,e[7]),t.Cartesian3.add(e[7],o,e[7]),t.Cartesian3.add(e[7],c,e[7]),t.Cartesian3.add(e[7],C,e[7]),e};const na=new t.Matrix3;c.computeTransformation=function(a,e){n.Check.typeOf.object("box",a),r.defined(e)||(e=new t.Matrix4);const i=a.center,s=t.Matrix3.multiplyByUniformScale(a.halfAxes,2,na);return t.Matrix4.fromRotationTranslation(s,i,e)};const ra=new e.BoundingSphere;c.isOccluded=function(a,t){if(!r.defined(a))throw new n.DeveloperError("box is required.");if(!r.defined(t))throw new n.DeveloperError("occluder is required.");const i=e.BoundingSphere.fromOrientedBoundingBox(a,ra);return!t.isBoundingSphereVisible(i)},c.prototype.intersectPlane=function(a){return c.intersectPlane(this,a)},c.prototype.distanceSquaredTo=function(a){return c.distanceSquaredTo(this,a)},c.prototype.computePlaneDistances=function(a,e,t){return c.computePlaneDistances(this,a,e,t)},c.prototype.computeCorners=function(a){return c.computeCorners(this,a)},c.prototype.computeTransformation=function(a){return c.computeTransformation(this,a)},c.prototype.isOccluded=function(a){return c.isOccluded(this,a)},c.equals=function(a,e){return a===e||r.defined(a)&&r.defined(e)&&t.Cartesian3.equals(a.center,e.center)&&t.Matrix3.equals(a.halfAxes,e.halfAxes)},c.prototype.clone=function(a){return c.clone(this,a)},c.prototype.equals=function(a){return c.equals(this,a)},a.OrientedBoundingBox=c}));