define(["exports","./GeometryOffsetAttribute-2bff0974","./Transforms-4ee811db","./Matrix2-c430e55a","./ComponentDatatype-9e86ac8f","./defaultValue-81eec7ed","./RuntimeError-8952249c","./GeometryAttribute-51ed9bde","./GeometryAttributes-32b29525","./IndexDatatype-bed3935d","./VertexFormat-7df34ea5"],(function(t,e,a,n,i,r,o,s,m,u,l){"use strict";const c=new n.Cartesian3,f=new n.Cartesian3,d=new n.Cartesian3,p=new n.Cartesian3,C=new n.Cartesian3,y=new n.Cartesian3(1,1,1),h=Math.cos,_=Math.sin;function x(t){t=r.defaultValue(t,r.defaultValue.EMPTY_OBJECT);const e=r.defaultValue(t.radii,y),a=r.defaultValue(t.innerRadii,e),s=r.defaultValue(t.minimumClock,0),m=r.defaultValue(t.maximumClock,i.CesiumMath.TWO_PI),u=r.defaultValue(t.minimumCone,0),c=r.defaultValue(t.maximumCone,i.CesiumMath.PI),f=Math.round(r.defaultValue(t.stackPartitions,64)),d=Math.round(r.defaultValue(t.slicePartitions,64)),p=r.defaultValue(t.vertexFormat,l.VertexFormat.DEFAULT);if(d<3)throw new o.DeveloperError("options.slicePartitions cannot be less than three.");if(f<3)throw new o.DeveloperError("options.stackPartitions cannot be less than three.");this._radii=n.Cartesian3.clone(e),this._innerRadii=n.Cartesian3.clone(a),this._minimumClock=s,this._maximumClock=m,this._minimumCone=u,this._maximumCone=c,this._stackPartitions=f,this._slicePartitions=d,this._vertexFormat=l.VertexFormat.clone(p),this._offsetAttribute=t.offsetAttribute,this._workerName="createEllipsoidGeometry"}x.packedLength=2*n.Cartesian3.packedLength+l.VertexFormat.packedLength+7,x.pack=function(t,e,a){if(!r.defined(t))throw new o.DeveloperError("value is required");if(!r.defined(e))throw new o.DeveloperError("array is required");return a=r.defaultValue(a,0),n.Cartesian3.pack(t._radii,e,a),a+=n.Cartesian3.packedLength,n.Cartesian3.pack(t._innerRadii,e,a),a+=n.Cartesian3.packedLength,l.VertexFormat.pack(t._vertexFormat,e,a),a+=l.VertexFormat.packedLength,e[a++]=t._minimumClock,e[a++]=t._maximumClock,e[a++]=t._minimumCone,e[a++]=t._maximumCone,e[a++]=t._stackPartitions,e[a++]=t._slicePartitions,e[a]=r.defaultValue(t._offsetAttribute,-1),e};const A=new n.Cartesian3,b=new n.Cartesian3,w=new l.VertexFormat,k={radii:A,innerRadii:b,vertexFormat:w,minimumClock:void 0,maximumClock:void 0,minimumCone:void 0,maximumCone:void 0,stackPartitions:void 0,slicePartitions:void 0,offsetAttribute:void 0};let v;x.unpack=function(t,e,a){if(!r.defined(t))throw new o.DeveloperError("array is required");e=r.defaultValue(e,0);const i=n.Cartesian3.unpack(t,e,A);e+=n.Cartesian3.packedLength;const s=n.Cartesian3.unpack(t,e,b);e+=n.Cartesian3.packedLength;const m=l.VertexFormat.unpack(t,e,w);e+=l.VertexFormat.packedLength;const u=t[e++],c=t[e++],f=t[e++],d=t[e++],p=t[e++],C=t[e++],y=t[e];return r.defined(a)?(a._radii=n.Cartesian3.clone(i,a._radii),a._innerRadii=n.Cartesian3.clone(s,a._innerRadii),a._vertexFormat=l.VertexFormat.clone(m,a._vertexFormat),a._minimumClock=u,a._maximumClock=c,a._minimumCone=f,a._maximumCone=d,a._stackPartitions=p,a._slicePartitions=C,a._offsetAttribute=-1===y?void 0:y,a):(k.minimumClock=u,k.maximumClock=c,k.minimumCone=f,k.maximumCone=d,k.stackPartitions=p,k.slicePartitions=C,k.offsetAttribute=-1===y?void 0:y,new x(k))},x.createGeometry=function(t){const o=t._radii;if(o.x<=0||o.y<=0||o.z<=0)return;const l=t._innerRadii;if(l.x<=0||l.y<=0||l.z<=0)return;const y=t._minimumClock,x=t._maximumClock,A=t._minimumCone,b=t._maximumCone,w=t._vertexFormat;let k,v,P=t._slicePartitions+1,F=t._stackPartitions+1;P=Math.round(P*Math.abs(x-y)/i.CesiumMath.TWO_PI),F=Math.round(F*Math.abs(b-A)/i.CesiumMath.PI),P<2&&(P=2),F<2&&(F=2);let g=0;const V=[A],D=[y];for(k=0;k<F;k++)V.push(A+k*(b-A)/(F-1));for(V.push(b),v=0;v<P;v++)D.push(y+v*(x-y)/(P-1));D.push(x);const E=V.length,M=D.length;let T=0,G=1;const L=l.x!==o.x||l.y!==o.y||l.z!==o.z;let O=!1,I=!1,z=!1;L&&(G=2,A>0&&(O=!0,T+=P-1),b<Math.PI&&(I=!0,T+=P-1),(x-y)%i.CesiumMath.TWO_PI?(z=!0,T+=2*(F-1)+1):T+=1);const N=M*E*G,R=new Float64Array(3*N),U=e.arrayFill(new Array(N),!1),S=e.arrayFill(new Array(N),!1),B=P*F*G,W=6*(B+T+1-(P+F)*G),q=u.IndexDatatype.createTypedArray(B,W),Y=w.normal?new Float32Array(3*N):void 0,J=w.tangent?new Float32Array(3*N):void 0,X=w.bitangent?new Float32Array(3*N):void 0,Z=w.st?new Float32Array(2*N):void 0,j=new Array(E),H=new Array(E);for(k=0;k<E;k++)j[k]=_(V[k]),H[k]=h(V[k]);const K=new Array(M),Q=new Array(M);for(v=0;v<M;v++)Q[v]=h(D[v]),K[v]=_(D[v]);for(k=0;k<E;k++)for(v=0;v<M;v++)R[g++]=o.x*j[k]*Q[v],R[g++]=o.y*j[k]*K[v],R[g++]=o.z*H[k];let $,tt,et,at,nt=N/2;if(L)for(k=0;k<E;k++)for(v=0;v<M;v++)R[g++]=l.x*j[k]*Q[v],R[g++]=l.y*j[k]*K[v],R[g++]=l.z*H[k],U[nt]=!0,k>0&&k!==E-1&&0!==v&&v!==M-1&&(S[nt]=!0),nt++;for(g=0,k=1;k<E-2;k++)for($=k*M,tt=(k+1)*M,v=1;v<M-2;v++)q[g++]=tt+v,q[g++]=tt+v+1,q[g++]=$+v+1,q[g++]=tt+v,q[g++]=$+v+1,q[g++]=$+v;if(L){const t=E*M;for(k=1;k<E-2;k++)for($=t+k*M,tt=t+(k+1)*M,v=1;v<M-2;v++)q[g++]=tt+v,q[g++]=$+v,q[g++]=$+v+1,q[g++]=tt+v,q[g++]=$+v+1,q[g++]=tt+v+1}if(L){if(O)for(at=E*M,k=1;k<M-2;k++)q[g++]=k,q[g++]=k+1,q[g++]=at+k+1,q[g++]=k,q[g++]=at+k+1,q[g++]=at+k;if(I)for(et=E*M-M,at=E*M*G-M,k=1;k<M-2;k++)q[g++]=et+k+1,q[g++]=et+k,q[g++]=at+k,q[g++]=et+k+1,q[g++]=at+k,q[g++]=at+k+1}if(z){for(k=1;k<E-2;k++)at=M*E+M*k,et=M*k,q[g++]=at,q[g++]=et+M,q[g++]=et,q[g++]=at,q[g++]=at+M,q[g++]=et+M;for(k=1;k<E-2;k++)at=M*E+M*(k+1)-1,et=M*(k+1)-1,q[g++]=et+M,q[g++]=at,q[g++]=et,q[g++]=et+M,q[g++]=at+M,q[g++]=at}const it=new m.GeometryAttributes;w.position&&(it.position=new s.GeometryAttribute({componentDatatype:i.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:R}));let rt=0,ot=0,st=0,mt=0;const ut=N/2;let lt;const ct=n.Ellipsoid.fromCartesian3(o),ft=n.Ellipsoid.fromCartesian3(l);if(w.st||w.normal||w.tangent||w.bitangent){for(k=0;k<N;k++){lt=U[k]?ft:ct;const t=n.Cartesian3.fromArray(R,3*k,c),e=lt.geodeticSurfaceNormal(t,f);if(S[k]&&n.Cartesian3.negate(e,e),w.st){const t=n.Cartesian2.negate(e,C);Z[rt++]=Math.atan2(t.y,t.x)/i.CesiumMath.TWO_PI+.5,Z[rt++]=Math.asin(e.z)/Math.PI+.5}if(w.normal&&(Y[ot++]=e.x,Y[ot++]=e.y,Y[ot++]=e.z),w.tangent||w.bitangent){const t=d;let a,i=0;if(U[k]&&(i=ut),a=!O&&k>=i&&k<i+2*M?n.Cartesian3.UNIT_X:n.Cartesian3.UNIT_Z,n.Cartesian3.cross(a,e,t),n.Cartesian3.normalize(t,t),w.tangent&&(J[st++]=t.x,J[st++]=t.y,J[st++]=t.z),w.bitangent){const a=n.Cartesian3.cross(e,t,p);n.Cartesian3.normalize(a,a),X[mt++]=a.x,X[mt++]=a.y,X[mt++]=a.z}}}w.st&&(it.st=new s.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:Z})),w.normal&&(it.normal=new s.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:Y})),w.tangent&&(it.tangent=new s.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:J})),w.bitangent&&(it.bitangent=new s.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:X}))}if(r.defined(t._offsetAttribute)){const a=R.length,n=new Uint8Array(a/3),r=t._offsetAttribute===e.GeometryOffsetAttribute.NONE?0:1;e.arrayFill(n,r),it.applyOffset=new s.GeometryAttribute({componentDatatype:i.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:n})}return new s.Geometry({attributes:it,indices:q,primitiveType:s.PrimitiveType.TRIANGLES,boundingSphere:a.BoundingSphere.fromEllipsoid(ct),offsetAttribute:t._offsetAttribute})},x.getUnitEllipsoid=function(){return r.defined(v)||(v=x.createGeometry(new x({radii:new n.Cartesian3(1,1,1),vertexFormat:l.VertexFormat.POSITION_ONLY}))),v},t.EllipsoidGeometry=x}));